# Pandas와 Numpy

## Pandas가 뭐지?

Pandas 한국어로 '판다스'는 Series, DataFrame의 자료구조를 이용해 데이터 분석 기능을 제공하는 파이썬의 라이브러리 중 하나이다. 자료 분석을 위한 각종 함수와 클래스로 이뤄져 있어 많은 분야에서 활용되고 있다.

Series는 1차원 배열 형태로 이뤄져 있는 자료 구조로 index 번호와 value 둘로 나눠져 출력된다. 딕셔너리와 비슷하다.

DataFrame은 2차원 테이블, 쉽게 말해 표 형태로 출력된다. 이 표가 하얀색과 밝은 회색으로 번갈아 표시되므로 마치 '판다' 처럼 보여 판다스라 부르는가 싶다.

## Jupyter Notebook으로 Pandas 활용하기

### 1. 시작하기

Pandas를 쓰기 위해서는 import가 필요하다.

```py
import pandas as pd
```

관용적으로 pd라 줄여 부른다. 1차원 배열 Series 생성은 다음과 같이 할 수 있다.

### 2. Series(시리즈) 생성

```py
series = pd.Series([1, 2, 3])
```

함수는 꼭 대소문자를 구분하여 써야 한다. DataFrame도 마찬가지이다. 리스트에 value 값을 묶어 생성하면 index는 기본적으로 0-base 0부터 시작하는 번호가 부여된다.

```py
0    1
1    2
2    3
dtype: int64
```

데이터 타입에는 여러가지가 있다. 정수를 나타내는 int, 실수를 나타내는 float, 문자열과 숫자가 뒤섞이면 object로 표시한다.

자료를 좀 다뤄본 사람들이라면 가끔 빈 칸으로 표시되는 부분들을 만나곤 했을 것이다. Series와 DataFrame에서는 자료가 없다면 그냥 비워두지 않고 **NaN, None**을 기입하여 값이 없다는 것을 표시한다.

Nan이라던가 none은 비었다는 뜻이 아니라 일종의 변수나 데이터로 들어가기 때문에 오류가 발생할 수 있다.

### 3. index 지정하기

물론 index를 사용자가 지정해줄 수도 있다. 간단하게 index=[숫자, 문자] 형식으로 설정 가능하다.

```py
series1 = pd.Series([1, 2, 3], index=[1, 2, 3])

series2 = pd.Series([1, 2, 3], index=['a', 'b', 'c'])
```

index= 을 생략하고 그냥 리스트만 적어도 알아서 index를 부여해주긴 한다. 그러나 나는 가독성을 위해 index= 를 명시하는 것을 좀 더 선호한다.

```py
series3 = pd.Series([1, 2, 3], ['a', 'b', 'c'])
```

### 4. 이름 붙이기

내가 생성한 Series에 이름을 붙일 수도 있다.
```py
series1.name = '첫 번째 시리즈'
```

index에 이름을 붙이려면 이렇게 하면 된다.

```py
series1.index.name = '문자열 인덱스'
```

결과

```py
문자열 인덱스
a    1
b    2
c    3
Name: 첫 번째 시리즈, dtype: int64
```

### 5. 딕셔너리로 시리즈 생성하기

파이썬의 딕셔너리와 판다스의 Series는 비슷한 점이 많다. 아니, 거의 똑같다. 그래서 딕셔너리로도 손쉽게 Series 생성이 가능하다.

```py
city = pd.Series({
    '서울':9631482,
    '부산':3393191,
    '인천':2632035,
    '대전':1490158
    })
```

결과

```py
서울    9631482
부산    3393191
인천    2632035
대전    1490158
dtype: int64
```

## Series에 데이터 추가/삭제하기

### 1. 데이터 추가

이미 존재하는 시리즈에 데이터를 추가하려면 index = value를 매칭시키면 된다. 광주광역시를 추가해보자. 광주의 인구가 1421760이라고 할 때 아래와 같이 적으면 된다.

```py
city['광주'] = 1421760
```

### 2. 데이터 덮어쓰기

부산의 인구를 수정할 일이 생겼다. 부산의 인구는 예전보다 줄어든 3298213명으로 집계되었다. 데이터를 추가하는 것과 마찬가지로 index를 찾아 새로운 값을 할당해주면 된다

```py
city['부산'] = 3298213
```

### 3. 데이터 삭제

대전광역시를 삭제해보자. del 명령어를 써서 간편하게 삭제할 수 있다.

```py
del city['대전']
```

DataFrame 형태에서는 del 명령어가 열에만 적용되고 행에 적용하기는 힘들다. 그래서 drop()이란 함수도 존재한다. drop을 쓰는 방법은 아래와 같다.

```py
city.drop('대전')
```

그런데 drop 시킨 후 city를 불러오면 뭔가 이상한 점이 있다

```py
서울    9631482
부산    3393191
인천    2632035
대전    1490158
광주    1421760
dtype: int64
```

데이터가 삭제되지 않고 그대로 있다. 어떻게 된 일일까? drop() 함수는 실제로 데이터가 없어지지는 않고 없어진 모습만 반영해주기 때문에 실제로 조작된 부분은 없다.

SQL을 다룰 때 commit이라던가 confirm을 안 해주면 데이터가 제대로 안 들어가는 경우가 가끔 있는데, 이것과 비슷하다고 보면 된다. inplace=True를 이용해 확인시키면 drop이 제대로 이행된다

```py
city.drop('대전', inplace=True)
```

## Series 인덱싱

인덱싱이란 특정 index 위치를 찾아가는 것을 뜻한다. index로 찾아간 다음 그에 맞는 value 값을 반환하는 구조다.

JSON 자료형에서 데이터 뽑는 문법이랑 비슷하지만, 거기서 더 나아가 loc, iloc 같은 함수를 사용하면 더 쉽게 데이터를 뽑을 수 있다.

### 1. 일반 인덱싱

JSON이랑 똑같이 변수[0]번째 값을 뽑아보자.

```py
s1 = pd.Series([95, 100, 88, 70, 55, 86], index= ['김나리', '나미리', '지대한', '박영웅', '이상식', '오근환'])
s1[0]
```

그러면 95가 반환될텐데, 경고 메세지도 함께 뜰 것이다.

```code
FutureWarning: Series.__getitem__ treating keys as positions is deprecated. In a future version, integer keys will always be treated as labels (consistent with DataFrame behavior). To access a value by position, use `ser.iloc[pos]`
```

그냥 앞으로 데이터 뽑을 때는 iloc 이용해서 뽑으란 소리다. iloc를 사용하는 법은 경고문 말미에 잘 나와있다. 저 말대로 데이터를 뽑아보자.

```py
s1.iloc[0]
```

결과는 똑같이 95가 잘 나온다. iloc와 loc는 DataFrame으로 넘어가는 훨씬 많이 쓰인다.

### 2. 데이터 슬라이싱

슬라이싱은 데이터의 일부만 추출하는 것을 뜻한다. s1에서 '지대한'부터 '이상식'까지 점수를 뽑고 싶다면 index 문자를 이용하거나 번호를 이용하는 방법이 있다.

```py
s1['지대한':'이상식']
s1[2:5]
```

결과

```py
지대한    88
박영웅    70
이상식    55
dtype: int64
```

응? 이상식은 index 상으로 4인데 왜 5까지 자르냐? 2:4를 넣어보면 '지대한'과 '박영웅'까지만 출력되는 것을 볼 수 있다. 즉 index 2번째~3번째만 출력되고 4번째는 잘리는 거다. 따라서 index 5번째까지 넣어줘야 원하는 값을 얻어낼 수 있다.

### 3. 원하는 index만 따로 빼기

index 문자만 따로 가져와 순서를 뒤바꿔 출력할 수도 있다.

이상식, 김나리, 오근환, 지대한의 성적을 출력하려 한다. 리스트로 만들어 출력시키면 된다.

```py
s1[['이상식', '김나리', '오근환', '지대한']]
```

결과

```py
이상식    55
김나리    95
오근환    86
지대한    88
dtype: int64
```

여기서 그냥 간과하고 넘어갈 수 있는 중요한 사실이 있다.

**리스트를 한번 더 리스트로 묶어서 출력한다**

s1['이상식'] 하나만 출력할 때는 아무 문제가 없다. 그런데 둘 이상을 출력하려고 s1['이상식', '김나리']을 넣는 순간 keyError가 난다. **index 검색에는 하나의 값만 들어가기 때문이다.** 따라서 하나의 값을 리스트로 묶어 보내줘야 여러 값을 돌려준다.

## Series 연산

value 값을 이용하여 연산도 할 수 있다. 점수가 80점 이상인 사람만 출력하고 싶을 때 이렇게 할 수 있다.

```py
s1[s1 > 80].sort_values(ascending=False)
```

결과

```py
나미리    100
김나리     95
지대한     88
오근환     86
dtype: int64
```

부연설명하자면, sort_values()란 value값을 오름차순 출력하고 ascending=False는 오름차순 출력을 False로 바꾸어 내림차순으로 출력하도록 만드는 함수이다. 이곳저곳 쓸 구석이 많으니 알아두면 좋다.

그 밖에 상당히 많은 연산자를 사용할 수 있다. 다른 방법들은 공식문서나 타 블로그를 참조하면 되겠다.